# Session Workflow - Compact Reference
# MANDATORY-REREAD: before-whats-next-queries

## Session = Long-term Memory
purpose: persist state across conversation resets (context window cleanup)
mapping: 1-session = 1-chore = 1-branch = 1-branch-metadata-file

## Auto-Detection
on-startup: git-branch → .claude/branches/<sanitized> → load-session-file
user-asks: "What's next?" or "What are we working on?"
manual: "Read .claude/sessions/<file>.md"

## CRITICAL: Determining "What's Next"
ALWAYS-run-in-order:
  1: git branch --show-current (authoritative current branch)
  2: .claude/tools/get-current-session.sh (verify session mapping)
  3: Read .claude/sessions/<session-file>.md (find Next Steps section)
NEVER: guess or assume current branch

## Session Files
location: .claude/sessions/
format: chore-<desc>.md
content: goal, done, todo, context, files-changed, next-steps
update: beginning-work, after-milestone, before-pause, when-blocked, BEFORE-commit
commit: atomic (session+code in same commit)

## Branch Metadata
location: .claude/branches/
format: chore-<desc> (/ → -)
content: session:<file>, status:<state>, type:chore
size: 6-8 lines (ultra-compact)

## Workflow
start: create-branch → .claude/tools/create-branch-metadata.sh → creates-metadata+session
work: implement → stage-changes → update-session → commit-atomic → push
pause: stage → update-session → commit → mark-status
resume: switch-branch → auto-loads-correct-session
complete: mark-session-complete → merge-PR

## Key Patterns
fresh-conversation ≠ lost-context (session file persists state)
reset-context-window: start-new-conversation, read-session, quality-restored
branch-switch = session-switch (automatic via metadata)
commit-regularly: session-updates = code-documentation

## Tools
get: .claude/tools/get-current-session.sh
create: .claude/tools/create-branch-metadata.sh

## Benefits
resumable: pick-up-where-left-off
traceable: maps-to-github-issues
handoff: teammates-read-session-understand-work
memory: external-state-outside-context-window
