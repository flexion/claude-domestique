# Testing Strategy - Compact Reference
# Plugin development = integration testing, not unit testing

when: after-implementation (commands, agents, skills, hooks)
strategy: integration-testing (install in test projects, verify commands work)
pyramid: integration > validation > documentation
test: commands-work, skills-auto-invoke, hooks-block, config-loads, scripts-execute
skip: unit-tests (plugin is definitions, not logic)
placement:
  integration: test-in-3-projects (simple-D365, client-frontend, client-backend)
  validation: verify-commands-output, verify-skills-trigger, verify-hooks-block
validation-checklist:
  install: /plugin install session-workflow@local (succeeds)
  next: /next (shows current session)
  create-session: /create-session (creates branch+metadata+session)
  check: /check commit (shows tech-specific checklist)
  context-loader: loads .claude/context/*.yml on session start
  session-detector: auto-loads session on "what's next?"
  test-runner: executes correct commands per tech stack
  hooks: blocks commits when checks fail
pattern: install → test-command → verify-output → next-command
test-projects:
  simple-D365: typescript-node, github, terraform
  client-frontend: react-typescript, azure-devops, frontend-last
  client-backend: java-spring, azure-devops, expand-contract
quality: commands-work-in-all-projects, zero-breaking-changes, migration-successful
anti-patterns: unit-testing-markdown, testing-bash-without-integration, assuming-works-without-validation
run:
  integration: after-each-component (command, skill, agent, hook)
  full-validation: before-phase-complete, before-PR
coverage: all-commands-tested-in-all-3-projects, all-skills-validated, all-hooks-verified
